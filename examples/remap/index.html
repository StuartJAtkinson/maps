<!DOCTYPE html>
<html lang="en">
<head>
  <base target="_top">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">  

  <title>Joric's Remap - Leaflet</title>
  <link rel="shortcut icon" type="image/x-icon" href="data:," />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.toolbar.js/0.1.0/Leaflet.Toolbar.min.css" integrity="sha512-GA6tz0ONkXAXGUnZU9M7mMkiOiXuXis56gRc73qvS+hXP0Sgb/mXihcqs6haKhes6mMeCPIdopIDixMwnnd+Iw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.toolbar.js/0.1.0/Leaflet.Toolbar.min.js" integrity="sha512-5jHQLJ93JywT7NbjOuyHQzqLsTNYc7mjj0U5bBmsnrE1P9+4qqjKak0H+8jSlTzeNcbtDiTbV68pMQNTXbSTHQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.min.css">
  <script src="https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.9/dist/vendor.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.min.js"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-mouse-position@1.2.0/src/L.Control.MousePosition.min.css">
  <script src="https://cdn.jsdelivr.net/npm/leaflet-mouse-position@1.2.0/src/L.Control.MousePosition.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/leaflet-search@4.0.0/dist/leaflet-search.src.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-search@4.0.0/dist/leaflet-search.src.min.css">

<!--
  <link rel="stylesheet" href="leaflet.css" />
  <script src="leaflet.js"></script>
  <link rel="stylesheet" href="leaflet.toolbar.min.css"/>
  <script src="leaflet.toolbar.min.js"></script>
  <link rel="stylesheet" href="leaflet.distortableimage.css"/>
  <script src="vendor.js"></script>
  <script src="leaflet.distortableimage.js"></script>
  <script src="L.Control.MousePosition.js"></script>
-->

  <style>
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
    }
    #map {
      height: 100%;
      width:  100%;
    }
    #controls {
      position: absolute;
      margin: auto;
      left: 0;
      right: 0;
      bottom: 0;

      z-index: 1000;
      margin-bottom: 40px;
      
      text-align: center;
      width: 50%;
    }
    .slider {
      width: 100%;
    }
  </style>
</head>
<body>

<div id="map"></div>
<input id="file" type='file' hidden/>

<script>
let defaultLocalData = {
  'LondonWorld': {
    remap: {
      world: { size: 262144, center:[131072,131072] },
      image: 'https://joric.github.io/maps/examples/data/LondonWorld.jpg',
      markers: 'https://joric.github.io/maps/examples/data/geojson.markers.folon.json',
      corners: [{"lat":51.567501756256505,"lng":-0.1764177405505252},{"lat":51.567501756256505,"lng":0.06345199242442146},{"lat":51.41815601816625,"lng":-0.1764177405505252},{"lat":51.41815601816625,"lng":0.06345199242442146}],
      controlPoints:{},
      smoothing: 0.0428,
      power: 5.0,
      activeLayers: {'Markers': true},
      provider: 'CartoDB_Voyager',
      warped: true,
    }
  }
};

maps = {
  'LondonWorld' : { name: 'London', scale: 1, offset: {x:0, y:0},
    regions: {
      'WestminsterWorld' : { scale: 0.6, offset: {x:-104300, y:27900}, rotation: 0.57 },
      'CamdenWorld': { scale: 1, offset: {x:-79000, y:74000}, rotation: 0 },
      'IslingtonWorld': { scale: 0.95, offset: {x:-26600, y:66500}, rotation: 0.57 },
      'HackneyWorld': { scale: 0.95, offset: {x:19100, y:44000}, rotation: 0.78 },
      'BankofEnglandWorld': { scale: 1, offset: {x:-32000, y:35500} },
      'BromleyGladesWorld': { scale: 1, offset: {x:0, y:0} },
      'StPaulsWorld': { scale: 1, offset: {x:3000, y:0} },
      'CoventGardenWorldSpace': { scale: 1, offset: {x:1500, y:-2000} },
    },
  },
}

let localDataName = 'joricsRemap';

let mapId = 'LondonWorld';
let settings = null;
let circleMarker = null;

function setSelection(latlng) {
  removeSelection();
  if (latlng) {
    circleMarker = L.circleMarker(latlng, {radius: 10, color: 'red'}).addTo(map);
    setTimeout(removeSelection, 10000);
  }
}
function removeSelection() {
  if (circleMarker) map.removeLayer(circleMarker);
}

// fetch local settings, if any
if (!localStorage.getItem(localDataName)) {
  fetch(localDataName+'.json').then(r=>r.json()).then(data=>{
    localData = data;
    updateMarkers();
    console.log('saving local settings');
    settings = localData[mapId];
    saveSettings();
    location.reload();
  })
}

let localData = JSON.parse(localStorage.getItem(localDataName)) || defaultLocalData;
settings = localData[mapId];

function saveSettings() {
  //console.log(localData);
  localStorage.setItem(localDataName, JSON.stringify(localData));
}

// we can have multiple areas in a single map, that one matches the name
let area = mapId;

let london = [51.505, -0.09];
let pos = london;
let zoom = 11;
let globalImage = null;

const map = L.map('map', {
  //zoomSnap: 0.1,
  //wheelDebounceTime: 100,
}).setView(pos, zoom);

let markersGroup = L.layerGroup();
//let imgGroup = L.distortableCollection(); // doesn't hide the image, only toolbar
let imgGroup = L.layerGroup(); // doesn't show the image after hiding

settings.remap = settings.remap||{};
settings.remap.activeLayers = settings.remap.activeLayers||{};

if (settings.remap.activeLayers['Markers']==true) {
  map.addLayer(markersGroup);
}

if (settings.remap.activeLayers['Images']==true) {
  map.addLayer(imgGroup);
}

let baseLayers = {};

// open street map is seriously better than voyager, because it has names

baseLayers['OpenStreetMap_Mapnik'] = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
});

baseLayers['CartoDB_Voyager'] = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
  subdomains: 'abcd',
  maxZoom: 20
});

baseLayers['Esri_WorldImagery'] = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
});

baseLayers['googleSat'] = L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
});

baseLayers['googleStreets'] = L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
});

baseLayers['googleHybrid'] = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
});

baseLayers['googleTerrain'] = L.tileLayer('http://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
});

baseLayers['googleTraffic'] = L.tileLayer('https://{s}.google.com/vt/lyrs=m@221097413,traffic&x={x}&y={y}&z={z}', {
        maxZoom: 20,
        minZoom: 2,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
    });


baseLayers['yandex core'] = new L.TileLayer('https://core-renderer-tiles.maps.yandex.net/tiles?l=map&x={x}&y={y}&z={z}&lang=en', {
    reuseTiles: true, 
    updateWhenIdle: false
});

baseLayers['yandex sat'] = new L.TileLayer('https://core-sat.maps.yandex.net/tiles?l=map&x={x}&y={y}&z={z}&lang=en', {
    reuseTiles: true, 
    updateWhenIdle: false
});

function updateCRS(provider) {
  if (settings.remap.provider.match( /yandex/gi )) {
    map.options.crs = L.CRS.EPSG3395;
  } else {
    map.options.crs = L.CRS.EPSG3857;
  }
}

settings.remap.provider = settings.remap.provider||'OpenStreetMap_Mapnik';
for (const [provider, baseLayer] of Object.entries(baseLayers)) {
  if (settings.remap.provider == provider) {
    map.addLayer(baseLayer);
    updateCRS();
  }
}

let layercontrol = L.control.layers(baseLayers, {'Markers': markersGroup, 'Images': imgGroup}).addTo(map);

map.on('baselayerchange', function(e) {
  settings.remap.provider = e.name;
  updateCRS();
  saveSettings();
});

map.on('overlayadd', function(e) {
  settings.remap.activeLayers[e.name] = true;

  // see https://github.com/publiclab/Leaflet.DistortableImage/issues/1323#issuecomment-2295487916
  // distortableimage apparently doesn't reappear on adding, let's reload the image then
  if (e.name == 'Images') {
    loadImages();
  }

  saveSettings();
});

map.on('overlayremove', function(e) {
  delete settings.remap.activeLayers[e.name];
  saveSettings();
});

map.on('moveend zoomend', function(e) {
  settings.center = [map.getCenter().lat, map.getCenter().lng]; // avoid circular refs here
  settings.zoom = map.getZoom();
  saveSettings();
});

if (settings.center && settings.zoom) {
  map.setView(settings.center, settings.zoom);
}

L.control.mousePosition().addTo(map);


let warpCaption = ()=>settings.remap.warped ? 'To Projected' : 'To Warped';

L.Control.MyButton = L.Control.extend({
    onAdd: function(map) {
        var btn = L.DomUtil.create('button', 'my-button');
        btn.innerHTML = warpCaption();
        L.DomEvent.on(btn, 'click', function() {
          settings.remap.warped = !settings.remap.warped;
          btn.innerHTML = warpCaption();
          updateMarkers();
        });
        return btn;
    }
});


L.control.myButton = function(opts) {
    return new L.Control.MyButton(opts);
}

L.control.myButton({ position: 'topright' }).addTo(map);



function PointFromArray(loc) {
  return {x:loc[0], y:loc[1]};
}

function remapPoint(point, quadCorners, rectSize, rectCenter) {
  // Normalize point to 0-1 range
  let nx = (point.x + rectCenter.x) / rectSize.x;
  let ny = 1 - (point.y + rectCenter.y) / rectSize.y;

  // Unpack quadrilateral corners
  let [topLeft, topRight, bottomLeft, bottomRight] = quadCorners;

  // Interpolate x and y separately
  function interpolate(a, b, factor) {
    return a + factor * (b - a);
  }

  // Interpolation along the top and bottom edges
  let topEdgeX = interpolate(topLeft.x, topRight.x, nx);
  let topEdgeY = interpolate(topLeft.y, topRight.y, nx);

  let bottomEdgeX = interpolate(bottomLeft.x, bottomRight.x, nx);
  let bottomEdgeY = interpolate(bottomLeft.y, bottomRight.y, nx);

  // Final interpolation between the edges
  let x = interpolate(topEdgeX, bottomEdgeX, ny);
  let y = interpolate(topEdgeY, bottomEdgeY, ny);

  return {x, y};
}


function warpToControlPoints(point, controlPoints, smoothing = 1, power = 2) {
  let totalWeight = 0;
  let weightedXSum = 0;
  let weightedYSum = 0;

  // Calculate the warped position
  for (const { oldX, oldY, newX, newY } of Object.values(controlPoints)) {
    const dx = newX - oldX;
    const dy = newY - oldY;
    
    const distance = Math.sqrt((point.x - oldX) ** 2 + (point.y - oldY) ** 2);
    const adjustedDistance = Math.max(distance, smoothing);
    const weight = 1 / (adjustedDistance ** power);

    weightedXSum += (point.x + dx) * weight;
    weightedYSum += (point.y + dy) * weight;
    totalWeight += weight;
  }
  
  // Normalize the result
  if (totalWeight > 0) {
    return {
      x: weightedXSum / totalWeight,
      y: weightedYSum / totalWeight
    };
  } 
  
  // Fallback to original point if totalWeight is zero
  return point;
}

function processRegions(marker) {
  let [x, y] = marker.feature.geometry.coordinates;
  let area = marker.feature.properties.location;

  if (t = (maps[mapId].regions && maps[mapId].regions[area])) {
    x = x * t.scale + t.offset.x;
    y = y * t.scale + t.offset.y;
    if (t.rotation) {
      let cx = t.offset.x;
      let cy = t.offset.y;
      x = x - cx;
      y = y - cy;
      let tx = x * Math.cos(t.rotation) - y * Math.sin(t.rotation);
      let ty = x * Math.sin(t.rotation) + y * Math.cos(t.rotation);
      x = tx + cx;
      y = ty + cy;
    }
  }
  return {x: x, y: y};
}

function project(marker, controlPoints) {
  // process regions, get starting point
  let point = processRegions(marker);

  // do the bitmap remapping
  let worldCenter = PointFromArray(settings.remap.world.center);
  let worldSize = PointFromArray([settings.remap.world.size, settings.remap.world.size]);
  let corners = settings.remap.corners.map(corner => PointFromArray([corner.lng, corner.lat]));

  point = remapPoint(point, corners, worldSize, worldCenter);

  // then warp to control points
  if (settings.remap.warped) {
    // if it's a control point, just return saved coordinates
    if (p = controlPoints[marker.feature.properties.title]) return [p.newY, p.newX];
    point = warpToControlPoints(point, controlPoints, settings.remap.smoothing, settings.remap.power);
  }

  // return point as latlng
  return [point.y, point.x];
}

function loadMarkers() {
  fetch(settings.remap.markers).then(r=>r.json()).then(data=>{

    let markers = L.geoJSON(data, {
      style: f => {color: f.properties.color},
      filter: f=> {

        let o = f.properties;
        let area = o.location;
        let type = o.description;
        let skip = (area != mapId && !(maps[mapId].regions && maps[mapId].regions[area]));

        if (!o.description || !o.title) skip= true;

        // hide some of the location markers on the base map
        if (mapId == Object.keys(maps)[0]) {
          if (['City','Town'].includes(type) && area != mapId && o.ref_id!='07310FF5') skip = true;
          if (type == 'Military Base' && o.ref_id != '0732F385') skip = true;
        }

        return !skip;
      },
      pointToLayer: function (feature, latlng) {
        let marker = L.marker(latlng, {draggable: true, opacity: 1});
        marker.on('drag', markerDragged)
        //marker.on('contextmenu', markerContextMenu)
        return marker;
      }
    })

    markers.bindPopup(l => { 
      let name = l.feature.properties.title;
      let content = '<pre>'+JSON.stringify(l.feature, null, 2)+'</pre>';

      let latlng = l.getLatLng();

      let strLL = String([latlng.lat, latlng.lng]);
      content += '<br/>'+strLL+' <a href="https://www.google.com/maps/search/'+encodeURIComponent(strLL)+'" target=_blank>What\'s there?</a>';

      if (settings.remap.controlPoints[name]) {
        content += '<br/><br/><button id="unbind-marker-btn">Unbind Marker</button>';
      }
      content += '<br/><br/>Possible location: <span id="possible-location">searching...</span>';
      content += '<br/><br/><form id="search-location-form"><input id="search-location-input"> <button id="search-location-btn" type="submit">Search Location</button></form>';

      l.on('popupclose', removeSelection);

      setTimeout(function() {

        if (input=document.querySelector('#search-location-input')) {
          let name = l.feature.properties.title;
          getLocationByName(name, function(data, latlng){
            setSelection(latlng);
            let div = document.querySelector('#possible-location');
            if (data) {
              let a = document.createElement('div');
              a.textContent = data[0].display_name;
              let button = document.createElement('button');
              button.textContent = 'Set to this location';
              button.onclick = function() { searchLocation(name, name, latlng); }

              div.replaceChildren(a, button);

            } else {
              div.textContent = 'Not found';
            }
          })

          if (e=document.querySelector('#search-location-form')) {
            document.querySelector('#search-location-input').value = name;
            e.onsubmit = function() {
              searchLocation(input.value, name, latlng);
              return false; // critical to prevent reload on submit
            }
          }
        }
        if (e=document.querySelector('#unbind-marker-btn')) e.onclick = function() { unbindMarker(l.feature.properties.title)};
      }, 250, l);

      return content;
    })
    markers.bindTooltip(l => l.feature.properties.title)
    markersGroup.addLayer(markers);
    updateMarkers();


    map.addControl( new L.Control.Search({
      layer: markers,
      hideMarkerOnCollapse: true,
      initial: false,
    }) );


  })
}


function reloadImage() {
  if (globalImage) map.removeLayer(globalImage);
  delete globalImage;

  globalImage = L.distortableImageOverlay(settings.remap.image, {
    mode: 'lock',
    selected: true,
    //actions: [L.DragAction, L.ScaleAction, L.DistortAction, L.RotateAction, L.FreeRotateAction, L.LockAction, L.OpacityAction, L.BorderAction, L.ExportAction, L.DeleteAction, L.RestoreAction],
    actions: [L.ScaleAction, L.RotateAction, L.OpacityAction, L.RestoreAction, L.LockAction],
    corners: settings.remap.corners,
  }).on('update', imageUpdated).on('load', updateMarkers)

  imgGroup.addLayer(globalImage);
}

function loadImages() {
  reloadImage();
}

function updateMarkers() {
  let markers = markersGroup.getLayers(0)[0];
  if (!markers) return;

  let controlPoints = {};
  for (marker of Object.values(markers._layers)) {
    let o = marker.feature.properties;
    if (e = settings.remap.controlPoints[o.title]) {
      let latlng = project(marker, {});
      controlPoints[o.title] = {
        oldX: latlng[1],
        oldY: latlng[0],
        newX: settings.remap.controlPoints[o.title][1],
        newY: settings.remap.controlPoints[o.title][0],
      };
    }

    marker && marker.dragging && (settings.remap.warped ? marker.dragging.enable() : marker.dragging.disable());
  }

  for (marker of Object.values(markers._layers)) {
    let o = marker.feature.properties;
    let loc = marker.feature.geometry.coordinates;
    marker.setOpacity(settings.remap.controlPoints[o.title] && settings.remap.warped ? 1 : .3);
    marker.setLatLng( project(marker, controlPoints ) );
  }
}

function imageUpdated(e) {
  settings.remap.corners = e.target.getCorners();
  updateMarkers();
  saveSettings();
}

function markerDragged(e) {
  // every dragged marker gets in control points
  let marker = e.target;
  let o = marker.feature.properties;
  let loc = marker.feature.geometry.coordinates;
  settings.remap.controlPoints[o.title] = [e.latlng.lat, e.latlng.lng];
  saveSettings();
  updateMarkers();
}

function unbindMarker(name) {
  if (confirm('Are you sure you want to unbind this marker?')) {
    name = decodeURIComponent(name);
    delete settings.remap.controlPoints [ name ];
    saveSettings();
    updateMarkers();
  }
}

function markerContextMenu(e) {
  unbindMarker(e.target.feature.properties.title);
}

function copyToClipboard(text) {
  let input = document.body.appendChild(document.createElement("input"));
  input.value = text;
  input.focus();
  input.select();
  document.execCommand('copy');
  input.parentNode.removeChild(input);
  console.log(text + ' copied to clipboard');
}

let subAction = L.Toolbar2.Action.extend({
  initialize:function(map,myAction){this.map=map;this.myAction=myAction;L.Toolbar2.Action.prototype.initialize.call(this);},
  addHooks:function(){ this.myAction.disable(); }
});

new L.Toolbar2.Control({
    position: 'bottomleft',

    actions: [

      // share button
      L.Toolbar2.Action.extend({
        options: {
          toolbarIcon:{html: '&#x1F517;', tooltip: 'Share'},
          subToolbar: new L.Toolbar2({ 
            actions: [

              subAction.extend({
                options:{toolbarIcon:{html:'About This Map', tooltip: ''}},
                addHooks:function() {
                  let url = 'https://github.com/joric/maps/wiki/Fallout-London#remapping';
                  window.open(url, '_blank');
                  subAction.prototype.addHooks.call(this); // closes sub-action
                }
              }),


              subAction.extend({
                options:{toolbarIcon:{html:'&times;', tooltip: 'Close'}}
              }),

            ],
          })
        }
      }),

      // settings button
      L.Toolbar2.Action.extend({
        options: {
          toolbarIcon:{html: '&#x1F4C1;', tooltip: 'Files'},
          subToolbar: new L.Toolbar2({ 
            actions: [

              subAction.extend({
                options:{toolbarIcon:{html:'Load Settings', tooltip: 'Load Local Data'}},
                addHooks: function () {
                  loadLocalData();
                  subAction.prototype.addHooks.call(this);
                }
              }),

              subAction.extend({
                options:{toolbarIcon:{html:'Save Settings', tooltip: 'Save Local Data'}},
                addHooks:function() {
                  saveLocalData();
                  subAction.prototype.addHooks.call(this);
                }
              }),

              subAction.extend({
                options:{toolbarIcon:{html:'Load Defaults', tooltip: 'Reset Local Data'}},
                addHooks: function () { 
                  if (confirm('Are you sure you want to reset settings?')) {
                    resetLocalData();
                  }
                  subAction.prototype.addHooks.call(this);
                }
              }),

              subAction.extend({
                options:{toolbarIcon:{html:'Export Markers', tooltip: 'Export All Markers as GeoJSON'}},
                addHooks:function() {
                  exportMarkers();
                  subAction.prototype.addHooks.call(this);
                }
              }),


              subAction.extend({
                options:{toolbarIcon:{html:'&times;', tooltip: 'Close'}}
              }),
            ],
          })
        }
      }),
    ],
}).addTo(map);


function loadLocalDataFile() {
  var file = document.querySelector("#file").files[0];
  if (file) {
    var reader = new FileReader();
    reader.readAsText(file, "UTF-8");
    reader.onload = function (evt) {
      let data = evt.target.result;
      evt.target.value = null;
      try {
        localData = JSON.parse(data);
        settings = localData[mapId];
        console.log('New settings loaded.');
        saveSettings();

        location.reload();

      } catch(e) {
        console.log(e);
      }
    }
    reader.onerror = function (evt) {
      alert('error reading file');
    }
  }
}

function loadLocalData() {
  document.querySelector('#file').onchange = function(e) {
    loadLocalDataFile();
  }
  document.querySelector('#file').value = null;
  document.querySelector('#file').accept = '.json';
  document.querySelector('#file').click();
}

async function saveTextToFile(text, filename) {
  const fileHandle = await window.showSaveFilePicker({
    suggestedName: filename,
    types: [{
      description: 'JSON Files',
      accept: {'text/json': ['.json']},
    }],
  });
  const writableStream = await fileHandle.createWritable();
  await writableStream.write(text);
  await writableStream.close();
}

function saveLocalData() {
  let str = localStorage.getItem(localDataName);
  let data = JSON.parse(str);
  //let cp = data[mapId].remap.controlPoints;
  //for (name of Object.keys(cp))) cp[name] = cp[name].map(e=>parseFloat(e));
  let filename = localDataName + '.json';
  saveTextToFile(JSON.stringify(data, null, 2), filename);
}

function resetLocalData() {
  localStorage.removeItem(localDataName);
  location.reload();
}

function exportControlPoints() {
  let data = settings.remap.controlPoints;
  let filename = 'controlPoints.'+mapId+'.json';
  saveTextToFile(JSON.stringify(data, null, 2), filename);
}


function exportMarkers() {
  let markers = markersGroup.getLayers(0)[0];
  let data = {'type': 'FeatureCollection', 'features':[]}

  for (marker of Object.values(markers._layers)) {
    let o = marker.feature.properties;
    let loc = marker.feature.geometry.coordinates;
    let f = structuredClone(marker.feature)
    let latlng = marker.getLatLng();
    f.geometry.coordinates[0] = latlng.lat;
    f.geometry.coordinates[1] = latlng.lng;
    f.geometry.coordinates[2] = loc[2] / 128 * 1.828; // 128 units = 1.828m
    data.features.push(f)
  }

  let filename = 'markers.'+mapId+'.json';
  saveTextToFile(JSON.stringify(data, null, 2), filename);
}

function getLocationByName(name, callback) {
  let q = encodeURIComponent(name);
  const url = `https://nominatim.openstreetmap.org/search?q=${q}&format=json&limit=1`;
  fetch(url).then(r => r.json()).then(data => {
    if (data.length > 0) {
      const latitude = data[0].lat;
      const longitude = data[0].lon;
      let latlng = L.latLng([latitude, longitude]);
      return callback(data, latlng);
    } else {
      return callback();
    }
  })
  return true;
}

function searchLocation(placeName, oldName, oldLatLng) { 
  getLocationByName(placeName, function(data, latlng) {
    map.closePopup();
    if (!data || !latlng) {
      alert('Place not found');
      return
    }

    const latitude = data[0].lat;
    const longitude = data[0].lon;
    const displayName = data[0].display_name;
    //console.log(JSON.stringify(data, null, 2));

    let text = `Are you sure you want to set new control point?`
    + `\n\n${data[0].name}\n${data[0].addresstype}\n\n${data[0].display_name}\n[${latitude}, ${longitude}]`;

    setSelection(latlng);

    map.flyTo(latlng, map.getZoom());//, {duration: .5});

    map.once('moveend', function() {

      if (confirm(text)) {
        settings.remap.controlPoints[oldName] = [latlng.lat, latlng.lng];
        map.flyTo(latlng);
        saveSettings();
        updateMarkers();
      } else {
        map.flyTo(oldLatLng, map.getZoom());//, {duration: .5});
      }
    });
  })
}

function searchLocation2(placeName, oldName, oldLat, oldLng) { 
  let q = encodeURIComponent(placeName);
  const url = `https://nominatim.openstreetmap.org/search?q=${q}&format=json&limit=1`;
  fetch(url)
      .then(response => response.json())
      .then(data => {
          if (data.length > 0) {
              const latitude = data[0].lat;
              const longitude = data[0].lon;
              const displayName = data[0].display_name;
              //console.log(JSON.stringify(data, null, 2));
              map.closePopup();

              let text = `Place found! Are you sure you want to set new control point?`
              + `\n\n${data[0].name}\n${data[0].addresstype}\n\n${data[0].display_name}\n[${latitude}, ${longitude}]`;

              let latlng = L.latLng([latitude, longitude]);
              let latlngOld = L.latLng([oldLat, oldLng]);
              let marker = L.circleMarker(latlng, {radius: 10, color: 'red'}).addTo(map);

              map.flyTo(latlng, map.getZoom());//, {duration: .5});

              map.once('moveend', function() {
                if (confirm(text)) {
                  settings.remap.controlPoints[oldName] = [latlng.lat, latlng.lng];
                  map.flyTo(latlng);
                  saveSettings();
                  updateMarkers();
                  map.removeLayer(marker);
                } else {
                  map.flyTo(latlngOld, map.getZoom());//, {duration: .5});
                  map.removeLayer(marker);
                }
              });

          } else {
              alert('Place not found');
          }
      })
      //.catch(error => alert('Error:', error));
}

window.onload = e => {

  loadMarkers();
  loadImages();

  let [sm,pw] = [document.querySelector('#smoothing'), document.querySelector('#power')];
  updateSlider(sm, settings.remap.smoothing);
  updateSlider(pw, settings.remap.power);

  function updateSliderTitle(c) {
    c.title = c.id + ': ' + c.value;
    updateMarkers();
  }

  function updateSlider(c, value) {
    c.value = value;
    updateSliderTitle(c);
  }

  function sliderEvent(e) {
    if (e.target.id=='smoothing') settings.remap.smoothing = e.target.value;
    if (e.target.id=='power') settings.remap.power = e.target.value;
    updateSliderTitle(e.target);
    saveSettings();
  }

  sm.oninput = sm.onchange = sliderEvent;
  pw.oninput = pw.onchange = sliderEvent;
}

</script>

<div id="controls">
  <div><input type="range" min="0.0" step="0.00001" max="0.2" value="0.1" class="slider" id="smoothing"></div>
  <div><input type="range" min="0.0" step="0.00001" max="10" value="0.5" class="slider" id="power"></div>
</div>

</body>
</html>
